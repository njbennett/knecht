# knecht Development Rules for AI Agents

## Project Philosophy

**knecht** is a git-native task tracker designed primarily for AI agents to work in highly structured, incremental workflows.

### Core Design Principles:

1. **Agent-First Design**: Optimize for AI agents working autonomously, not human convenience
   - Programmatic interfaces over interactive UX
   - Structured data over free-form text
   - If humans need friendly interfaces, we'll build separate tools that consume knecht's output

2. **Test-Driven Development**: Every feature starts with a failing test

3. **Self-Hosting**: We use knecht to build knecht (eating our own dog food)

4. **Pain-Driven Development**: Features are added only when their absence hurts
   - Track pain counts explicitly
   - Implement at pain count ~3-5

5. **Simplest Possible**: Sequential IDs, pipe-delimited files, no complexity

6. **YAGNI**: You Ain't Gonna Need It - defer features until they're proven necessary

7. **Structured Workflow**: Guide agents through incremental, testable work
   - Start → Test → Implement → Complete → Commit → Reflect

8. **One Task Per Session**: Complete one task fully before ending the session
   - Work on a single task from start to completion
   - When a task is complete, prepare to commit and end the session
   - If a task reveals subtasks or blockers, file them as new tasks and end the session
   - Don't continue to the next task automatically - let the user decide what to work on next

### Extreme Programming

We reject industry conventional wisdom that says "perfect is the enemy of good."

We turn practices that work up to maximum: TDD, refactoring, simplicity, testing.

If something is good practice, doing it 100% is better than doing it 80%.

## Architecture Overview

### Module Structure

```
knecht/
├── src/
│   ├── main.rs      # CLI command routing and user-facing logic
│   └── task.rs      # Task struct and data operations (read/write/modify)
├── tests/
│   └── integration_test.rs  # End-to-end tests via CLI
└── .knecht/
    └── tasks        # Self-hosting: knecht's own tasks
```

**Design Decision**: Start with minimal modules. Only extract new modules when you feel pain from a file being too large or having multiple concerns.

### Data Format

File: `.knecht/tasks`

```
1|open|Write first test
2|done|Make it pass
3|open|Commit the code
```

Format: `{id}|{status}|{title}|{description}` (description is optional)

Pipe-delimited, line-based, git-friendly diffs, human-readable, sequential IDs. **Do NOT change this format** without discussion.

## TDD Workflow - MANDATORY

### Every Feature Follows This Process:

1. **Write a Failing Test First**
   - Add test to `tests/integration_test.rs`
   - Run `cargo test` - it should FAIL
   - If test passes before you write code, the test is wrong

2. **Make It Pass with Simplest Code**
   - Write minimal code to make test pass
   - Don't add features not required by the test
   - Avoid premature abstractions

3. **Refactor If Needed**
   - Only after tests pass
   - Keep tests passing during refactoring
   - Extract functions/modules when you feel pain

4. **Track Work in knecht**
   - Use `knecht add` for new tasks
   - Use `knecht done` when complete
   - Commit `.knecht/tasks` with your changes

### Example TDD Cycle

```bash
cargo test  # Should FAIL - write test first
# Implement feature in src/
cargo test  # Should PASS
knecht done task-N
git commit -m "task-N: Description"
```

## Code Style Guidelines

### Error Handling

**Current state (v0.1)**: Simple `expect()` and `unwrap()` with helpful messages

```rust
let file = fs::File::open(path).expect("Failed to open tasks file");
```

Don't prematurely add complex error handling - YAGNI! Track it as a task when you hit actual problems.

### Function Design

- Keep functions small and focused
- Prefer pure functions (input → output) when possible
- Avoid hidden global state

### Module Boundaries

**Current modules**:
- `main.rs`: CLI command parsing, user-facing output
- `task.rs`: Task struct, file I/O, data operations

**When to extract a new module**: When you feel pain from mixing concerns or file size.

## Cargo Warnings - Fix Immediately

```bash
cargo build
cargo clippy
```

**Zero tolerance for warnings**. Fix them before committing.

## Coverage and Untested Code

When running coverage checks and finding uncovered code:

1. **Delete the uncovered code first**
2. Analyze what the deleted code was doing and what behavior changed
3. Decide if the behavior change is acceptable:
   - If acceptable (dead code, unreachable defensive checks): leave it deleted
   - If unacceptable (important error handling, edge cases): write a test for it, then re-implement

Don't spend time trying to write tests for hard-to-reach code. Delete it and see what breaks in your analysis.

The goal: 100% coverage means every line has a reason to exist, proven by a test.

## Pain-Driven Feature Development

### Before Adding ANY Feature, Ask:

1. **Is there a failing test?** - No test = No feature. Period.

2. **Have I felt actual pain?**
   - "Might need" ≠ pain
   - "Would be nice" ≠ pain
   - "I can't do X and it's blocking me" = pain

3. **Am I tracking this in knecht?** - If it's not in `.knecht/tasks`, don't build it

4. **What's simpler?** - Could a shell alias or 3-line function solve this?

5. **Can I defer this?** - Almost always: YES

When pain count reaches ~3-5 instances, write a test and implement it.

## Testing Guidelines

### Integration Tests Over Unit Tests

Focus on integration tests via CLI in `tests/integration_test.rs`:
- Tests run the actual binary
- Tests verify end-to-end behavior
- Tests use temporary directories for isolation

```rust
#[test]
fn test_feature_X() {
    let temp = setup_temp_dir();
    let result = run_command(&["command", "args"], &temp);
    assert!(result.success);
    assert!(result.stdout.contains("expected output"));
    cleanup_temp_dir(temp);
}
```

**Why**: Integration tests catch more real-world issues for a CLI tool.

### Unit Tests

Add unit tests for complex parsing logic, algorithms, or edge cases in isolated functions.

## Performance & Optimization

Don't optimize prematurely. Simple file I/O, reading entire files into memory, and linear search are all fine for v0.1.

When performance pain is real (5+ pain count), track it as a task, write a test, then optimize.

## Git & Self-Hosting

### Commit Format

`task-N: Brief description of what changed`

### Self-Hosting Workflow

```bash
knecht next          # Get suggestion for what to work on
# Work on the suggested task
knecht done task-N   # Mark complete
git add .knecht/tasks src/ tests/
# IMPORTANT: Confirm with user before committing
git commit -m "task-N: Description"
```

**IMPORTANT**: Always confirm with the user before running `git commit`. Present the changes that will be committed and ask for approval.

### Session Scope

**Work on ONE task per session.** When you complete a task:

1. Mark it done with `knecht done task-N`
2. Respond to the reflection prompt
3. Prepare the commit (but confirm with user before committing)
4. **End the session** - don't automatically start the next task

If during your work you discover:
- The task needs to be broken into subtasks → file them with `knecht add` and end session
- Blockers exist → file tasks for the blockers and end session  
- Related improvements → file them as separate tasks and end session

The user will decide what to work on next. Don't assume you should continue working.

We eat our own dog food. Every knecht feature should be tracked IN knecht.

## Documentation

Update when:
- Adding a new command → README.md
- Changing data format → README.md and SPEC_V2_TDD.md
- Discovering architectural insights → this .rules file

Keep docs practical, current, and concise. Prefer examples over prose.

## Summary

**Always:**
- Write failing test first
- Make test pass with simplest code
- Track work in knecht itself
- Fix cargo warnings immediately
- Confirm with user before committing changes
- Commit `.knecht/tasks` with code changes
- Design for agents first - prioritize machine-readable output and programmatic interfaces
- Work on one task per session, then stop and let user decide next steps

**Never:**
- Add features without tests
- Add features without tracking in knecht
- Prematurely abstract or optimize
- Ignore cargo warnings
- Break existing tests

**When in doubt:** Ask "What's simpler?" and "Can I defer this?"
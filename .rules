# knecht Development Rules for AI Agents

## Project Philosophy

**knecht** is a git-native task tracker built on these core principles:

1. **Test-Driven Development**: Every feature starts with a failing test
2. **Self-Hosting**: We use knecht to build knecht
3. **Pain-Driven Development**: Features are added only when their absence hurts
4. **Simplest Possible**: Sequential IDs, pipe-delimited files, no complexity
5. **YAGNI**: You Ain't Gonna Need It - defer features until they're proven necessary

## Architecture Overview

### Module Structure

```
knecht/
├── src/
│   ├── main.rs      # CLI command routing and user-facing logic
│   └── task.rs      # Task struct and data operations (read/write/modify)
├── tests/
│   └── integration_test.rs  # End-to-end tests via CLI
└── .knecht/
    └── tasks        # Self-hosting: knecht's own tasks
```

**Design Decision**: Start with minimal modules. Only extract new modules when you feel pain from a file being too large or having multiple concerns.

### Data Format

File: `.knecht/tasks`

```
1|open|Write first test
2|done|Make it pass
3|open|Commit the code
```

Format: `{id}|{status}|{title}`

- **Pipe-delimited**: Simple to parse with `split('|')`
- **Line-based**: Git-friendly diffs
- **Human-readable**: Can be edited directly
- **Sequential IDs**: Just integers, no UUIDs or hashes

**Do NOT change this format** without discussion. It's simple by design.

## TDD Workflow - MANDATORY

### Every Feature Follows This Process:

1. **Write a Failing Test First**
   - Add test to `tests/integration_test.rs`
   - Run `cargo test` - it should FAIL
   - If test passes before you write code, the test is wrong

2. **Make It Pass with Simplest Code**
   - Write minimal code to make test pass
   - Don't add features not required by the test
   - Avoid premature abstractions

3. **Refactor If Needed**
   - Only after tests pass
   - Keep tests passing during refactoring
   - Extract functions/modules when you feel pain

4. **Track Work in knecht**
   - Use `knecht add` for new tasks
   - Use `knecht done` when complete
   - Commit `.knecht/tasks` with your changes

### Example TDD Cycle

```bash
# 1. Write failing test in tests/integration_test.rs
cargo test  # Should FAIL

# 2. Implement feature in src/
cargo test  # Should PASS

# 3. Track completion
knecht done task-N
git commit -m "task-N: Description"
```

## Code Style Guidelines

### Error Handling

**Current state (v0.1)**: Simple `expect()` and `unwrap()` with helpful messages

```rust
// Current approach - acceptable for v0.1
let file = fs::File::open(path)
    .expect("Failed to open tasks file");

// Don't prematurely add complex error handling - YAGNI!
```

**When to improve**: Track it as a task when you hit actual problems.

### Function Design

- Keep functions small and focused
- Prefer pure functions (input → output) when possible
- Avoid hidden global state

### Module Boundaries

**Current modules**:
- `main.rs`: CLI command parsing, user-facing output
- `task.rs`: Task struct, file I/O, data operations

**When to extract a new module**: When you feel pain from mixing concerns or file size.

## Cargo Warnings - Fix Immediately

```bash
cargo build
cargo clippy
```

**Zero tolerance for warnings**. Fix them before committing.

- Remove unused imports/variables immediately
- Use `cargo clippy --fix` for auto-fixes
- Add doc comments to public functions

## Pain-Driven Feature Development

### Before Adding ANY Feature, Ask:

1. **Is there a failing test?** - No test = No feature. Period.

2. **Have I felt actual pain?**
   - "Might need" ≠ pain
   - "Would be nice" ≠ pain
   - "I can't do X and it's blocking me" = pain

3. **Am I tracking this in knecht?** - If it's not in `.knecht/tasks`, don't build it

4. **What's simpler?** - Could a shell alias or 3-line function solve this?

5. **Can I defer this?** - Almost always: YES

### Examples of Deferred Features

Track your pain count, but don't implement without discussion:

- ❌ Task descriptions/notes
- ❌ Blocked-by relationships  
- ❌ Priorities, due dates, tags
- ❌ Task update/search commands
- ❌ Multiple task files or config files

When pain count reaches ~3-5 instances, write a test and implement it.

## Testing Guidelines

### Integration Tests Over Unit Tests

Focus on integration tests via CLI in `tests/integration_test.rs`:
- Tests run the actual binary
- Tests verify end-to-end behavior
- Tests use temporary directories for isolation

```rust
#[test]
fn test_feature_X() {
    let temp = setup_temp_dir();
    let result = run_command(&["command", "args"], &temp);
    
    assert!(result.success);
    assert!(result.stdout.contains("expected output"));
    
    cleanup_temp_dir(temp);
}
```

**Why**: Integration tests catch more real-world issues for a CLI tool.

### Unit Tests

Add unit tests for complex parsing logic, algorithms, or edge cases in isolated functions.

## Performance & Optimization

Don't optimize prematurely. Simple file I/O, reading entire files into memory, and linear search are all fine for v0.1.

When performance pain is real (5+ pain count), track it as a task, write a test, then optimize.

## Git & Self-Hosting

### Commit Format

`task-N: Brief description of what changed`

### Self-Hosting Workflow

```bash
knecht list          # See what needs doing
# Work on task-N
knecht done task-N   # Mark complete
git add .knecht/tasks src/ tests/
# IMPORTANT: Confirm with user before committing
git commit -m "task-N: Description"
```

**IMPORTANT**: Always confirm with the user before running `git commit`. Present the changes that will be committed and ask for approval.

We eat our own dog food. Every knecht feature should be tracked IN knecht.

## Documentation

Update when:
- Adding a new command → README.md
- Changing data format → README.md and SPEC_V2_TDD.md
- Discovering architectural insights → this .rules file

Keep docs practical, current, and concise. Prefer examples over prose.

## Key Principles for Agents

**Always:**
- Write failing test first
- Make test pass with simplest code
- Track work in knecht itself
- Fix cargo warnings immediately
- Confirm with user before committing changes
- Commit `.knecht/tasks` with code changes

**Never:**
- Add features without tests
- Add features without tracking in knecht
- Prematurely abstract or optimize
- Ignore cargo warnings
- Break existing tests

**When in doubt:** Ask "What's simpler?" and "Can I defer this?"